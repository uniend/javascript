// 변수 선언 

//1. 자동으로 

/*
x = 5;
y = 5;
z = x + y;
console.log(z)
*/


// 2. var를 사용하여 

/*
var x = 5;
var y = 10;
var z = x + y;
*/

// var는 변수명 중복, 재할당이 기능하며, 함수 스코프를 가져, 함수내부에서 선언된 변수는 외부에서 접근할 수 없다.  
// 또한 변수는 엔진의 움직임에 따라, 선언, 초기화, 런타임할당 총 3가지 순서로 진행이 되는데 var의 경우 평가 과정에서 선언과 초기화가 동시에 이뤄지기 때문에 
// undefined가 할당되어 선언 이전에도 해당 변수를 사용해도 에러없이 undefined가 출력된다. 이를 코드가 끌여올려진다 하여 호이스팅이라 부른다. 
// 호이스팅, 중복이름선언이 가능한점에서 문제가 발생할 가능성이 높고 이를 방지하기 위해 호이스팅이 방지되는 let과 const가 생성되게 되었다. 따라서 최근에는 var를 쓰지 않는 추세이다. 


// 3. let을 이용하여 
// let은 중복선언이 불가, 재할당이 가능한 변수 선언문이다.
// 함수 스코프를 갖는 var와 달리 블록스코프를 지니고 있어 블록문 if, try,catch, 함수, for 문 내부에서 선언된 변수는 지역변수가 되어 블록 외부의 스코프에서 접근이 불가하다.  블록은 독립적인 스코프를 형성하며, 중복 선언이 가능합니다. 같은 이름의 변수가 다른 블록 내에서 선언되어도 서로에게 영향을 주지 않습니다.
// 블록 스코프 내에서 같은 이름의 변수가 중복 선언되면, 해당 블록 내에서 가장 가까운 변수를 사용합니다. 이를 "Shadowing"이라고도 합니다.
// 만약 블록 내에서 변수가 없다면, 한 단계 위에 있는 스코프의 변수를 참조합니다.
// 안에서 밖으로 나가는 형태이다. / 반대로 안에서 밖에 값을 수정가능하지만 밖에서 블록스코프안의 변수를 수정/접근이 불가하다. 
// let은 선언,초기화,할당과정중 선언만 먼저 이뤄지고 초기화는 런타임시점 할당과정에서 발생하기 때문에 선언이전 구역 tdz에서는 선언시 오류가 발생한다. 
// 따라서 호이스팅이 발생은 하지만 실행은 되지 않는다. 


/*
let x = 5;
let y = 7;
let a;
a = 3;
let z = x + y + a;
console.log(z)
*/


//3. const 
// const는 중복선언불가, 재할당 불가 인 변수 선언문이다. 
// const는 var와 let과 달리 선언,초기화,할당이 동시에 모두 이뤄지기 때문에 최초 선언과 동시에 할당을 함꼐 해주어야한다. 
// 선언만 할경우 해당 값에 값을 넣지 못하며 오류가 발생한다. 
// 또한 let과 마찬가지로 tdz 영역이 있어 호이스팅이 불가하다. 
// 또한 블록스코프를 가지고 있기 때문에 블록은 독립적인 스코프를 유지하고 있어 블록 스코프 별로 동일한 변수명이 선언이 가능하지며 서로 영향을 주지 않는다. 
// 만약 중복된 변수 선언이 있다면, 블록내부에서 동일한 변수명을 사용하지만, 없을 경우 한단계위에 스코프를 사용한다. 
// 외부에서는 ㅈ블록스코프로 접근이 불가하다. 이를 shadowing이라한다. 
// 

const x = 5;
const y = 3;
// const a;
const z = x + 7;
console.log(x+y)