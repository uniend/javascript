자바스크립트 요점 정리 


[변수 선언]

* 변수 선언 주의 사항 * 
   1. 문자, 숫자, $ ,_ 사용 
   2. 첫글자 술자 불가 
   3. 예약어 사용불가 
   4. 상수는 대문자 
   5. 읽기 쉽게 


  1. var :  똑같은 변수 재선언 가능 
            호이스팅이 발생해 선언 이전에 사용할 수있다. 
            -> 선언 이전선언된 사용될경우 undefined를 담고있다. 
            함수 스코프 
  
  2. let : 똑같은 변수 재선언 불가 
           내용 수정이 가능하다. 
           블록 스코프 
           할당 이전에 변수 사용이 불가하여 호이스팅이 발생x 

  3. const :  똑같은 변수 재선언 불가
              내용수정 불가, 선언과 할당이 동시에 하지않은면 에러발생 
              주로 변하지 않는 상수를 담을 때 사용한다. 
              할당 이전에 변수 사용이 불가하여 호이스팅이 발생x 
              블록 스코프 


  ** 블록 스코프(함수, if문,for문등,,) :  블록 스코프 안에서 선언된 변수는 블록 스코프 내부에서만 유효하다. 외부에서 접근할 수 없다(지역변수)
  ** 함수 스코프(함수) : 블록과 상관없이 스코프 외부에서 접근이 가능하지만, 유일하게 함수내부에선언된 경우만 지역 변수로 외부에서 접근및사용이 불가하다. 
  ** tip :  모든 변수를 const로 선언 후 변경될 여지가 있는 변수만을 let으로 변경하한다. 


  < 스코프에 따른 차이 >
    자바스크립트에서는 스코프영역에 따라 동일한 이름을 가진 변수가 다른 값을 가질 수 있다. 
    예를 들어 동일한 이름선언이 불가한 let이 같은이름으로 여러번 선언될 수 있다는 걸 말한다. 


  < 변수의 생성 단계 >

    - var 
    1. 선언/초기화 단계
    2. 할당단계  
    - var는 선언가 동시에 초기화 단게가 동시에 이뤄진다. 

    - let 
    1. 선언단계 
    2. 초기화 단계
    3. 할당단계

    - const 
    1. 선언 + 초기화+ 할당
    --> 선언과 동시에 할당이 이뤄져아한다. 
    --> 재할당이 불가하기 떄문 
    ex) const age;
        age = 30; 
        --> 에러 발생 
    
    * 초기화 단계는 undefined를 할당해주는 단게이다. 


  ----
  < let, const, var 의 차이점 >

  1. 변수명 재활용 
   -  var는 똑같은 변수명을 재사용 가능하지만, let과 const는 불가하다. 
  
  2. 내용 수정 가능 여부 
    - var와 let은 담긴내용 수정이 가능하지만 const는 불가하다. 
    * 예외사항) 
      - const로 선언된 객체와 배열은 수정이 가능하다. 
      ->  배열과 객체의 내용은 변경되지만, const로 선언된 변수가 담고있는건 배열의 주소, 객체의 주소이며, 해당 주소는 변경되지 않기 때문이다. 

  3. 호이스팅의 유무 
    - 실제 변수 선언 위치와 무관하게 항상 스코프 최상단으로 변수선언이 발생한것처럼 끌여올려진다하여 호이스팅이라 한다.
    - 호이스팅은 스코프 단위로 발생한다.  

    - 호이스팅이 발생하는 변수 
      - var
        - 호이스팅이 발생하며 선언이전에 사용할경우 에러없이 undefined가 할당되어있다. 

    - 호이스팅이 발생하지 않는 변수 
      - let, const 
       - 실제로 호이스팅은 발생하나. let과 const는 temporal dead zone의 영향으로 할당전에는 사용할 수 없도록 막혀있어 
         선언문 이전에 사용할 경우, 에러가 발생한다. 




-------------------------------------------------------------------------------------------------------------------------



[ 자료형 ]

1. 문자형 : string 
   ㄱ. 표기법 
    - 자스엔진에게 문자열임을 인지시켜주는 리터럴 
    const name = "mike"
    const name = 'mike'
    const name = `mike` (백틱)
    const name = '' --> 아무것도 적지 않은 빈 문자열도 string이다. 


    ㄴ. 문자형 응용 
    const aa = "마이크"
    const bb = "나는 "
    const cc = " 이다 . " 
    const age2 = 30;

    console.log(aa + bb + cc + age2 )

    <백틱의 특징>
    1. 백틱은 문자형에 변수를 사용할 떄 편리 * 
    ex)  const messsage = `그의 이름은 ${name}이다.`
    ex)  const messsage = `그의 이름은 ${name+10}이다.` --> 표현식도 가능하다. 
    2. 줄바꿈을 해도 에러가 나지 않는다. 

    <문자열 특이사항>
    1. '' == '    ' 의 결과값은 false 이다. 
    2. 문자열 리터럴 안에 '', 와 ""를 넣고 싶을떄 
      '""', "''" 감싸주면 된다. --> 같은 따음표를 사용하고 싶을떄 는 \'를 사용하면 된다. 
    3. \를 표기하고싶을떄는 \\ 두번 사용하면 된다. 
    4. '', ""안에 줄바꿈을 사용하고 싶을때는 \n




2. 숫자형 : number 
  const  age = 30;
  const PI = 3.14;

  console.log(1+2) // 더하기
  console.log(10 - 3 ) // 뺴기 
  console.log(3*2) // 곱하기
  console.log(6/3)  // 나누기 
  console.log(6%4)  // 나누고 남은 값 

  ? 숫자를 0으로 나눈다면? 
    ex) cosnt x = 1/0  --> infinity 무한대 

  ? 문자열을 숫자로 나눈다면? --> NaN (Not of Number)
    ex) const name = mike
        const y =  name/2 

  <숫자형 특이사항>
  1. 사칙연산이 가능하다. 
  2. 숫자와 관련된 작업시 NaN이 아닌지 항상 염두해둬야한다. 
  

3. 논리형 : boolean 

  const a = true; //참 
  const b = false; //거짓 


4. null / undefined 
  null 
  - 아무것도 없다라는 값. 
  - console.log( typeof null) // object 라는 결과 
  * 하지만 null은 객체가 아니다. --> 자스 초기버전의 오류 


 

-----------------------------------------------------------------------------------------------------------------------------------


[알림창]
- alert, prompt, comfirm 

  <단점>
    - 스크립트의 일시정지
    - 스타일링 불가 
    - 브라우저마다 모양이 다르다. 

1. alert // 알려줌
2. promt // 입력받음
    - 참의 결과값은 문자열이다. 
    - 취소시 null 값이 출력된다. 
    - 두개의 인수를 가지며 두번째 인자에서 default값을 입력할 수 있다. 
    


3. comrfirm //확인함 
  - alert와의 차이점 
      - alert는 확인 버튼만 존재하나 comfirm은 확인과 취소버튼이 있다. 
      - 결과값이 boolean형으로 도출되며 확인은 true, 취소는 false 


--------------------------------------------------------------------------------------------------------------------------------------------------------

[ 형변환 ]

  Q 형변환이 필요한 이유?
    if) 만약 자료형이 다른게 더해지면 어떠한 결과값이 발생할까?
        ex) "문자" + "문자" --> 문자형
            200 + 2000 --> 숫자형
            "문자" + 390  -->  ? 
            --> 에측하지 못한 다른 결과 값이 발생하기 때문 


    ㄱ. 자동형변환 
      "문자형" / 3 --> 결과값 숫자형 
      "문자형" / "문자형" --> 숫자형 
      - 연산/비교 시에 자동형변환이 주로 발생한다. 
      --> 예기치 못한 상황을 발생시키기때문에 명시적으로 형변환을 지켜주어 에러를 방지해야한다. 


    ㄴ. 명시적 형변환  - String(), Number(), Boolean() 

        1. String()
          - 문자형으로 변환 

        2. Number()
          - 숫자형으로 변환 
          - 문자와영어가 섞일경우 ) NaN
          - ture) 1
          - false ) 0 
          * 주의사항 -- 암기필요
            null --> 0
            undefined --> NaN
            0 --> false
            '0' --> ture;
            "" --> false
            ' " -> ture 

        3. Boolean()
          - 불린형으로 변환 
          - 0, "", null, NaN, undefined ) false  
            -> if문 조건문에서 활용되는 Falsy
          - 그외는 모두 ) ture 

--------------------------------------------------------------------------------------------------------------------

[ 연산자 ]

+ , - , * , / , %

- 응용 
- 거듭제곱 :  ** 

  Q) 나머지는 어디에 쓸까?
    - 홀수,짝수, 
    - %5 --> 5보다 작은 수 얻기 

  < 우선 순위 > 
    -  *, / > +,- 


  <연산자 줄여서 쓰기 >
    num += 5 ---> num = num + 5와 같다
      -- 더한뒤 넣어라! 

  < 증가 연산자 / 감소연산자 >
    - 값을 1만큼 증가 혹은 감소시킨다. 

    - 증가 연산자 ++ 
        - num ++ 
        - ++num 

    - 감소 연산자 -- 
        - num--
        - --num 

    Q) 연산자의 위치에 따른 차이는 ?  
        ex)  let num = 10; 
             let result = num++ // 10 
             let result = ++num // 11 

            num++ 의 경우 그 다음줄 부터 시행된다. 이전값을 담고있다. 
            ++num 의 경우 해당 줄부터 시행된다. 



    < 비교 연산자 >
      > ,  <,  >=, <=, ==, !=
      크다 ,작다, 크거나 같다, 작거나 같다 , 같다 , 같지 않다. 
      -- > 반환 값은 언제나 booleanr값이다. 

      * 특이 사항 
        비교 연산자에는 동등연산자와 일치연산자가 있다.  
        동등연산자 ==,
        일치 연산자  === 

        == 의 경우 타입과 무관하게 값만을 비교하지만 
        ===의 경우 늘어난 =의 숫자처럼 좀더 세부적으로 들어가 값의 타입까지 일치해야 true가 반환된다. 
        --> 따라서 코드를 작성할때는 일치연산자 ===을 쓰는것을 추천한다. 


        < 다양한 비교예시 >
          1. -50,000 ≤ num1 ≤ 50,000 
            a. 먼저 -500000 과 넘을 비교하여 결과값이 ture or false가 된다. 
            b. 비교연산자에서 true,false는 0 또는 1임이다.
            c. 따라서 0,1 <= 50000을 비교하는게 되어 제대로된 비교가 불가하다. 
            d. -50000 <= num1 && num1 <= 50000 이런식으로 접근하는게 타당하다. 

-----------------------------------------------------------------------------------------------------------------------------------------------------------
[ if 문 ]
- ()조건문의 값이 true면 실행하는 코드  
- 코드가 한줄 뿐이면  {} 를 생략할 수 있다. 

- if문이 판단하는 값은 
  1. boolean의 참/거짓
  2. Truthy(참으로 간주되는 값) / Falsy(거짓으로 간주되는 값) 값
  - 해당값을 조건으로 활용할 수 있습니다. 


  * Falsy의 종류 
    false
    null
    undefined
    0
    NaN
    빈 문자열 ("")

  * Truthy의 종류 
    -  Falsy 값 이외의 모든 값들을 포함
    1. 문자열, (빈 문자열 제외 )
    2. 숫자, (0 제외 )
    3. 객체,
    4.  배열 


    ---> 불리언이 아니더라도 JavaScript는 자동으로 Truthy나 Falsy로 변환하여 조건을 판단합니다. 


    1. if , else , else if 
      - if 는 true일때 실행
      - else는 false일떄 실행 
      - else if 만약 이게 맞다면 
      

    * if문의 조건에 !이들어간다면 false를 true로 바꿔사용하는것이기때문에 false값이 들어와야한다. 


    < treu/false와 비교 연산자가 if문에서 비교된다면?>
      ex)  if(!('age' in mike)<20)
          --> 객체 비교 in의 경우 결과값이 boolean으로 나타난다. 
          -->  ture/false < 20 과 동일한 형태 
          ** 비교연산자는 ture를 1로 판단 
          ** 비교 연산자는 false를 0으로 판단한다. 


    -----------------------------------------------------------------------------------------------------------------------------------------------

    [ 논리 연산자 ]
      1. || (or) : 하나라도 true면 true 
          - or은 첫번째 true를 발견하는 즉시 평가를 멈춘다. 
          < || 의 반환값 ? >
            -->  마지막 true값을 반환한다. 

      2. && (and) : 모든 값이 ture면 ture 
          - 첫번째 false를 발견하는 즉시 평가를 멈춘다. 
      3. not (Not) : ture와 false를 서로 반대값으로 변환 


      논리 연산자 코드 작성의 순서에 관한 tip 
        - 시간을 줄여 성능 최적화를 위한 작성하는 법 
        ex)  운전면허가 있고 시력이 좋은 여군
              - 운전면허 : 80%;
              - 시력이 : 60%;
              - 여군: 8%; 
              -> 여군인데 시력이 좋고 운전면허가 있는 사람 의 순서로 진행되어야함 

      ** 연산자에도 우선순위가 있다. 
        && > ||
        &&가 ||보다 우선 순위가 높다. 
        따라서 && ||를 하나의 조건에 함꼐 사용한다면 숫자 계산 처럼 || 비교 쪽에 ()를 감싸 먼저 할 수 있도록 해준다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------

[ 반복문 ]
- 동일한 작업을 여러번 반복 

1. for 
    for(let i = 0; i < 10; i++){
        // 반복할 코드 
    }
    * 자세히 살펴보기 
      ㄱ. 초기값 :  let i = 0
          - 반복문에 진입할떄 최초 한번만 실행된다. 
      ㄴ. 조건 :  i < 10 ;
          - false가 되면 멈춘다. 
      ㄷ. 반복문 실행후 작업될 영역
        - *후위연산자는 다음줄부터 실행된다는 사실! 
        - 따라서 반복문부터 실행을 마친 후에 실행한다. 


      <코드 진행의 순서 >
      1. 초기값 
      2. 조건문
      3. 실행문
      4. 후위연산자 
      5. 조건문
      6. 실행문
      7. 후위연산자
      8. 조건문 false시 탈출 


2. while 
    let i = 0;
    while(i < 10 ){
      // 반복할 코드 
      i++ (만약 해당 코드가 없다면 i의 값이 증가하지 안아 무한 반복될 수 있다는 점을 유의 )
    }
   
3. do while
    let i = 0; 
    do{
      i++;
    }while(i < 10)
    - while과 차이점 
      while: 주로 선 조건을 체크하고 반복을 시작할 때 사용합니다.
      do-while: 코드 블록을 최소한 한 번 실행하고 나중에 조건을 체크해야 하는 경우에 사용합니다.
      --> 즉, 조건문에 값이 false가 입력되더라도 한번은 코드를 실행합니다. 
      --> ture ,flase 상관없이 무조건 한번 된다고 생각하기 
      --> 주로 사용자에게 최소한번의 입력 기회를 줄때 사용 

< 반복문을 멈추는 방법 >
1. brack : 멈추고 즉시 빠져나옴
2. continue : 멈추고 반복문의 조건문으로 다시 이동 



<주의사항>
while(ture)는 무한반복을 발생합니다. 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ switch문 ]

switch(평가){
  case a :
  // a일떄 코드
  case b : 
  // b일떄 코드 
}
  <주의사항>
    - break를 만나지 않음 해당 케이스부터 브레이크가나올때가 전부 실행하는 특성이 있다. 
    따라서 break를 넣어줘야한다. 

    - case에 없느 경우 처리 ) 
      - default : 를 사용하여 처리한다. 


------------------------------------------------------------------------------------------------------------------------------------------------------------


[ 함수 선언문 ] funtion 
  - 비슷한 동작(기능) 재활용하기 
  - 이름이 있는 함수 선언 
  - 선언부와 호출부가 나눠져있다. 

  ※매개변수 : 함수내에서 전달된 값을 저장하는 임시변수(지역변수라 한다.)
              ** 지역변수는 함수 내부에서만 사용가능해 외부에서 사용이 불가하다. 
              ** 함수외부에서 선언된 변수를 함수 내부에서 사용은 가능하다. 
              ** 단 함수외부에서 선언된 변수를 함수내부에서 사용후 함수 호출부 이후로 해당 변수를 다시 사용하면 함수내부에서 업데이트 된 내용이 저장되어있다. 
  ※인수 : 함수 호출부에서 함수로 전달되는 값 
 
  ※지역변수 
      -- 함수 내부에서만 사용되는 매개변수를 지역변수라 한다. 
  ※전역변수 
      -- 함수 외부에서도 함수 내부에서도 사용가능한 변수를 전역에서 사용가능하다 하여 전역변수라 한다. 



  장점 : 
    1. 코드의 재사용이 효율적이다. 
    2. 유지보수가 간편하다. 

  ex) 대표적인 브라우저 함수 
    - console,alert,comfirm

  
  < 함수 작성법 >
    - 여러가지 작성 법이 있다. 

    1) 함수의 선언 
    funtion 함수명(매개변수){
      // 실행문 
    }
    
    ** 매개변수란 : 
      1. 매개변수는 없을 수도 / 하나일 수도 / 두개일 수도 있다. 


    2) 함수의 호출 
      함수명(); 


    <매개변수가 없는 함수 >
      // 에러를 띄어주는 함수작성 하기 
      funtion showError(){
        alert('에러발생 다시 시도 해주세요 ')
      }
      

    <매개변수가 하나 있는 함수>
      funtion showName(name){
        const msg = `hello ${name}`
        alert(msg)
      }
      Qa) 매개변수가 있으나 매개변수를 전달하지 않을경우 ?
          -- undefined의값이 뜬다. 


    < 인수가 하나도 전달되지 않을 경우 처리해주기  >
       - 함수 호출부에 인수가 전달되지않을경우, 함수내 지역 변수에 undefined값이 할당된다. 
       
       Q) undefined값이 들어 왔을 때 2가지 처리 방법 
          1. || 연산자 사용하기 
          2. default 매개변수 사용하기 

          < || 연산자 사용하기 >
            // 이름을 부르는 기능을 하는 함수 
            // 페이지 전체에 쓰이는 것이 아닌 특정 페이지에서 만 사용되는 기능으로 전역변수 필요없음 
            function sayName(name){
                let msg = name || 'replaceName'; // ||은 마지막 ture를 반환 
                console.log(msg)
            }
            sayName();  //replaceName
            sayName('Mike') // Mike

          
          < default 값 사용하기 >
          function sayName(name = 'defaultName'){
            let msg = `hello ${name}`
            console.log(msg)
          }
          sayName();
          sayName('Mike')


    < 값을 반환하는 함수 >
      -- return 활용하기 
      -- return 우측 값을 반환한다. 
      -- 지역변수 선언 없이 반환되는 값을 전역변수에 담아 활용할 수 있다.  
      -- return이 있으면 즉시 함수가 종료되기 때문에 함수를 종료할려는 목적으로 사용하기도 한다. 
      ※특이사항 
      -- 리턴문이 없는 함수는 항상 undefined를 반환합니다. 
      -- 우측에 반환할 값이 없이 return만 있어도 undefined를 반환합니다. 


      < 함수에서 return을 사용하는 이유 >
        1. 함수외부에서 값을 사용하기 위해서 
          - 콘솔로 할경우 로그에서는 보여지나, 값은 undefine로 활용할 수가겂다. 
        2. 값을 반환후 조기종료가 목표라면
        3. 유지보수, 가독성을 위하여 


      function add(num1,num2){
        return num1 + num2 
      }

      let result = add(1,2);
      console.log(result);


      function showError(){
        alert('이 함수오류가 발생했습니다.)
        return;
        alert('이 부분은 절대 실행되지 않습니다.)
      }

      const result = showError();
      console.log(result)



      <함수 tip >
      1. 한번에 한작업에 집중한다. 
      2. 읽기 쉽고 어떤 동작인지 알 수 있는 네이밍 
-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ 함수 표현식]
  - 이름없는 함수를 생성 후 할당

  let sayHello = function(){
    // 실행코드
  }
  sayHello(); 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

[함수 선언문과 함수 표현신의 차이점]
  - 호출 타이밍이 다르다. 

  함수 선언문 ) 
    - 어디서든 호출 할 수 있다. 
    * 함수 호이스팅이 발생하여 자바스크립트 엔진의 위에서 아래로 코드를 읽는 특성에도 불구하고 호출부가 선언부 보다 위에 있어도 작동한다. 
    
    이유: 자스엔진은 코드 실행전 선언부를 모두 찾아 미리 실행컨텍스트에 선언해두기 때문.. 
    ex) sayHello(); // hello 

        function sayHello(){
        console.log('hello')
        }

  
  함수 표현식 )  
    - 실행되지 않는다. 
    - 표현식의 경우 선언부는 const sayhello임으로 함수선언자체가 위에서 아래로 차례로 읽어가는 런타임 시점에 생성되기 떄문. 
    ex) sayHello();

        const sayHello = function(){
        console.log('hello')
        }

---------------------------------------------------------------------------------------------------------------------------------------------------------


[ 화살표 함수 ]
  - funtion이란 말 없이, 좀더 간략화 된 함수 
  * 리턴문이 한줄이라면 {} 생략가능 
  * 인수가 하나라면 ()로 생략가능 
  
  q)인수가 없는 경우라면 () 생략 가능한가?  No
    - 

 ex)  const sayHello = () => {} 


-------------------------------------------------------------------------------------------------------------------------------------------------------------
[ 지역변수와 전역변수의 차이 ]

  1. 전역변수와 지역변수의 명은 동일할 수 있다.
  2. 둘의 값은 서로 영향을 받지 않고 독립적인 값을 유지한다. 
  3. 만약 지역변수가 없다면 동일한이름을 가진 전역변수의 값을 사용한다.
  4. 전역변수 보다는 지역변수를 활용하는 습관을 가지자 
      ㄴ 전역변수가 많이지면 관리가 힘들어진다. 

Q) 전역변수와 함수 내부의 지역변수명이 동일 할 수 있을까 ? --> 가능하다 
  1.  함수와 내부에서 동일한 명의 변수를 선언할 수 있다. 
  2.  변수 내부의 값은 서로 영향을 받지 않는다. 

  ex) let msg = '전역변수'
      
      console.log(msg) // 전역변수 

      funtion sayMsg(name){
        let msg = '지역변수'
        console.log(msg + '' + name) // 지역변수 입니다. 
        console.log( + name) 
      }

      sayMsg('입니다.')
      sayMsg(); //undefined
      console.log(msg) // 전역변수 


  ex) let msg = '전역변수'
      
      console.log(msg) 

      function sayMsg(name){
        // let msg = '지역변수'
        console.log(msg + '' + name)
        console.log(name)  
      }

      sayMsg('입니다.')
      console.log(msg)
      --> 지역변수가 없다면 동일한 이름의 전역변수를 사용한다. 


  ------------------------------------------------------------------------------------------------------------------------------------------------------

  [ 객체 object]
    - 프로포티들로 구성되어있다. 
    - 접근, 추가, 수정, 삭제 등이 가능하다. 

    <프로포티의 구성>
    1. 키(key)
    2. 값(value)

    <객체의 형태>
    const Character = {
      name: 'mike',
      age : 48,
    }
    --> 프로포티의 키와 값이 동일할 경우 하나로 줄여쓰느 단축 프로퍼티가 가능하다. 
    ex) const Character = {
        name,
        age,
    }


    < 프로퍼티로 가능한 타입>
      1. 숫자,
      2. 문자열,
      3. boolean,
      4. 객체,
      5. 배열,
      6. 함수,
      7. null/undefined

    < 객체의 접근 >
    Character.name
    Character[age]

      1. 프로포티의 존재유무 확인 
          if) 접근하는 프로퍼티가 없는 프로퍼티라면 undefined를 반환한다.   
          --> undefined는 조건문에서 false이다.        
          -----------------------------------------------------------
          in 사용법 
            console.log('프로퍼티 키' in 객체명 )
            -->  존재한다면 true , 존재하지 않는다면 false가 나온다. 

      2. 프로포티 순회하기 
          - for in 접근 방법 
          for(x in mike){console.log(mike[x])} // mike['프로퍼티1'], mike['프로퍼티2'] 
          -- x에는 mike의 프로퍼티가 존재한다. 
          --> for in을 사용하여 모든 객체를 순회할 수 있다. 

    < 객체의 추가 >
    Character.name = '';
    Character[] = ''; ※주의사항 :  [ ' '] 접근할려는 프로퍼티를 문자열로 감싸줘야한다. 


    < 객체의 삭제 >
    delete Character.name

  -----------------------------------------------------------------------------------------------------------------------------------------------------------

  [ 메소드 ] method
    - 프로퍼티로 입력된 함수를 메소드라 부른다. 
    - 객체에 선언된 함수임으로 호이스팅과 무관하다. 

    ex) const superman(){
      name: 'july',
      age: 30,
      fly: function(){
        console.log('날아갑니다') // 메소드 
      }
      walk(){
        console.log('걸어갑니다.') // 단축구문 
      }
    }

    
    ---------------------------------------------------------------------------------------------------------------------------------------------------------

    [ this ]  * 어려운 구간 
    - 사용되는 위치에 따라 this가 가르키는 대상이 달라지는 특별한 코드 

     1. this는 실행하는 시점, 런타임 시점에 결정된다. 

    1) 일반함수의 메소드로 this가 사용된 경우 
        - 호출방식 obj.sayHello() 
        - obj 객체안에 this가 있다면 this는 해당 객체를 가리킨다. 

    2) 화살표 함수 내부에서 this가 사용된경우 
       - 화살표 함수는 자신만의 this를 가지지 않는다. 따라서 this의 해당하는 값을 외부을 가져온다. 
       -  상위 스코프의 메소드를 따르며
       - 최상단의 스코프 단위에사용된 화살표 함수라면 화살표함수는 전역객체를 가르킨다. 

       ※전역객체
         - 브라우저 : window()
         - node 환경 : global


-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ 배열 ] array 
- 순서가 있는 리스트 

let student = []


< 배열의 특징 >
1. 자바스크립트는 배열도 원래 객체이다. 하지만 둘을 그분 짓는 배열의 특징이 존재한다. 
?) 배열 과 객체의 차이점은 ? 
   1. 고유번호 index의 유무
   2. 순서의 중요도 
   3. 배열의 길이 length의 보유 



< 배열의 접근 >
- student[고유번호(index)]


2. 배열에는 문자, 숫자, 객체, 함수를 포함할 수 있다. 
3. 배열은 메소드를 가지고 있다. 
   - push() 배열끝에 요소 추가 / 원본유지여부 : 
   - pop() 배열끝에 요소 제거 / 원본유지여부 : 
   - unshift() 배열 앞에 요소 추가 / 원본유지여부 : 
   - shift() 배열앞에 요소 제거 / 원본 유지 여부 : 


< 배열의 순회 >
1. for 문 사용 
   for(let index = 0; index < day.length; index++){
    console.log(days[index])
   }
2. for of 사용 
   for(day of days){
    console.log(day)
   }





