자바스크립트 요점 정리 

[ 자바스크립트란? ]
  - 웹 브라우저에서 작동하는 인터프리터타입의 객체지향 동적언어이다. 
  - node.js와 같은 프레임워크 사용시 서버측 프로그래밍, 즉 브라우저 외부에서도 사용이 가능하다. 


  * 인터프리터란?
    - 자료형의 타입이 나중에 정해지는 것을 의미해, 타입을 지정할 필요가 없다. 


  객체 지향 프로그래밍이란 ?
  - 프로토타입 기반 프로그래밍 
    연관되어있는 변수와 메소드를 하나의 객체로 그룹화하며, 객체가 하나하나 독립된 프로그램처럼 운영되어 여러 프로젝트에서 부품처럼 재활용 될 수 있도록
    하는 프로그래밍 
---------------------------------------------------------------------------------------------------------------------------------------------------------
[변수 선언]  ** 이해

* 변수 선언 주의 사항 * 
   1. 문자, 숫자, $ ,_ 사용 
   2. 첫글자 술자 불가 
   3. 예약어 사용불가 
   4. 상수는 대문자 
   5. 읽기 쉽게 


  1. var :  똑같은 변수 재선언 가능 
            호이스팅이 발생해 선언 이전에 사용할 수있다. 
            -> 선언 이전선언된 사용될경우 undefined를 담고있다. 
            함수 스코프 
  
  2. let : 똑같은 변수 재선언 불가 
           내용 수정이 가능하다. 
           블록 스코프 
           할당 이전에 변수 사용이 불가하여 호이스팅이 발생x (tdz)

  3. const :  똑같은 변수 재선언 불가
              내용수정 불가, 선언과 할당이 동시에 하지않은면 에러발생 
              주로 변하지 않는 상수를 담을 때 사용한다. 
              할당 이전에 변수 사용이 불가하여 호이스팅이 발생x (tdz)
              블록 스코프 


  ** 블록 스코프(함수, if문,for문등,,) :  블록 스코프 안에서 선언된 변수는 블록 스코프 내부에서만 유효하다. 외부에서 접근할 수 없다(지역변수)
  ** 함수 스코프(함수) : 블록과 상관없이 스코프 외부에서 접근이 가능하지만, 유일하게 함수내부에선언된 경우만 지역 변수로 외부에서 접근및사용이 불가하다. 
  ** tip :  모든 변수를 const로 선언 후 변경될 여지가 있는 변수만을 let으로 변경하한다. 


  < 스코프에 따른 차이 >
    자바스크립트에서는 스코프영역에 따라 동일한 이름을 가진 변수가 다른 값을 가질 수 있다. 
    예를 들어 동일한 이름선언이 불가한 let이 같은이름으로 여러번 선언될 수 있다는 걸 말한다. 


  < 변수의 생성 단계 >

    - var 
    1. 선언/초기화 단계
    2. 할당단계  
    - var는 선언가 동시에 초기화 단게가 동시에 이뤄진다. 

    - let 
    1. 선언단계 
    2. 초기화 단계
    3. 할당단계

    - const 
    1. 선언 + 초기화+ 할당
    --> 선언과 동시에 할당이 이뤄져아한다. 
    --> 재할당이 불가하기 떄문 
    ex) const age;
        age = 30; 
        --> 에러 발생 
    
    * 초기화 단계는 undefined를 할당해주는 단게이다. 


  ----
  < let, const, var 의 차이점 >

  1. 변수명 재활용 
   -  var는 똑같은 변수명을 재사용 가능하지만, let과 const는 불가하다. 
  
  2. 내용 수정 가능 여부 
    - var와 let은 담긴내용 수정이 가능하지만 const는 불가하다. 
    * 예외사항) 
      - const로 선언된 객체와 배열은 수정이 가능하다. 
      ->  배열과 객체의 내용은 변경되지만, const로 선언된 변수가 담고있는건 배열의 주소, 객체의 주소이며, 해당 주소는 변경되지 않기 때문이다. 

  3. 호이스팅의 유무 
    - 실제 변수 선언 위치와 무관하게 항상 스코프 최상단으로 변수선언이 발생한것처럼 끌여올려진다하여 호이스팅이라 한다.
    - 호이스팅은 스코프 단위로 발생한다.  

    - 호이스팅이 발생하는 변수 
      - var
        - 호이스팅이 발생하며 선언이전에 사용할경우 에러없이 undefined가 할당되어있다. 

    - 호이스팅이 발생하지 않는 변수 
      - let, const 
       - 실제로 호이스팅은 발생하나. let과 const는 temporal dead zone의 영향으로 할당전에는 사용할 수 없도록 막혀있어 
         선언문 이전에 사용할 경우, 에러가 발생한다. 




-------------------------------------------------------------------------------------------------------------------------



[ 자료형 ]

1. 문자형 : string 
   ㄱ. 표기법 
    - 자스엔진에게 문자열임을 인지시켜주는 리터럴 
    const name = "mike"
    const name = 'mike'
    const name = `mike` (백틱)
    const name = '' --> 아무것도 적지 않은 빈 문자열도 string이다. 


    ㄴ. 문자형 응용 
    const aa = "마이크"
    const bb = "나는 "
    const cc = " 이다 . " 
    const age2 = 30;

    console.log(aa + bb + cc + age2 )

    <백틱의 특징>
    1. 백틱은 문자형에 변수를 사용할 떄 편리 * 
    ex)  const messsage = `그의 이름은 ${name}이다.`
    ex)  const messsage = `그의 이름은 ${name+10}이다.` --> 표현식도 가능하다. 
    2. 줄바꿈을 해도 에러가 나지 않는다. 

    <문자열 특이사항>
    1. '' == '    ' 의 결과값은 false 이다. 
    2. 문자열 리터럴 안에 '', 와 ""를 넣고 싶을떄 
      '""', "''" 감싸주면 된다. --> 같은 따음표를 사용하고 싶을떄 는 \'를 사용하면 된다. 
    3. \를 표기하고싶을떄는 \\ 두번 사용하면 된다. 
    4. '', ""안에 줄바꿈을 사용하고 싶을때는 \n




2. 숫자형 : number 
  const  age = 30;
  const PI = 3.14;

  console.log(1+2) // 더하기
  console.log(10 - 3 ) // 뺴기 
  console.log(3*2) // 곱하기
  console.log(6/3)  // 나누기 
  console.log(6%4)  // 나누고 남은 값 

  ? 숫자를 0으로 나눈다면? 
    ex) cosnt x = 1/0  --> infinity 무한대 

  ? 문자열을 숫자로 나눈다면? --> NaN (Not of Number)
    ex) const name = mike
        const y =  name/2 

  <숫자형 특이사항>
  1. 사칙연산이 가능하다. 
  2. 숫자와 관련된 작업시 NaN이 아닌지 항상 염두해둬야한다. 
  

3. 논리형 : boolean 

  const a = true; //참 
  const b = false; //거짓 


4. null / undefined 
  null 
  - 아무것도 없다라는 값. 
  - console.log( typeof null) // object 라는 결과 
  * 하지만 null은 객체가 아니다. --> 자스 초기버전의 오류 


 5. 심볼 (Symbol)
    - 유일하며, 변경불가능 한 값
    - 심불은 함수를 이용하여 생성한다. 
      ㄴ 언뜻 생성자 함수로 보이지만 생성자 함수가 아니며 new를 사용하지 않는다. new를 사용할시 타입 에러가 발생한다. 
    - 인수로 설명을 문자열로 전달할 수있으며 이 설명은 유일한 심볼값에 영향을 주지 않는다. 
    - 심불 값은 외부에 공개되지 않는다. 
    - 불린값으로 타입 변환이 가능하다. 


    < 표기 법 >
    1. const a = Symbol()
    2. const b = Symbol('mySymbol') //인수로 설명 전달 


    console.log(typeof a) // Symbol
    console.log(a) // Symbol()  외부값노출x 
    console.log( a == b, a===b ) // false, false 



    < 심볼이 사용되는 이유 >
      1. 고유한 프로퍼티를 생성하기 위해 사용한다. 
      2. 유일한 식별자를 생성한다. 
          ex) const a = Symbol();



< 원시타입과 객체타입 >
  - 원시타입 : 객체를 제외한 나머지 타입
              변경이 불가능한 값이다.
              값을 변경할 수 있는 방법은 : 재할당 뿐이다. 
              재할당시 값을 담는 새로운 주소가 확보되어 새로운 메모리 주소의 값으로 교체된다. 
              따라서 변수별로 독립적인 주소를 유지한다. 
              본래 주소의 값이 직접적으로 변경된 것이 아닌 새로운 주소에 담긴 값을 가리키게 된것으로 
              값이 변하지 않아 변경 불가능하다 표현한다. 

  - 객체타입 :  변경이 가능한 값을 말한다. 
                변수에 할당된값은 주소값이다. 
              제힐딩 없이, 참조한 주소를 통해 값을 직접 변경할 수 있다. 
              다만, 여러개의 변수가 하나의 동일한 주소를 공유 할 수 있어, 서로 영향을 주고받을 수있다. 



-----------------------------------------------------------------------------------------------------------------------------------


[알림창]
- alert, prompt, comfirm 

  <단점>
    - 스크립트의 일시정지
    - 스타일링 불가 
    - 브라우저마다 모양이 다르다. 

1. alert // 알려줌
2. promt // 입력받음
    - 참의 결과값은 문자열이다. 
    - 취소시 null 값이 출력된다. 
    - 두개의 인수를 가지며 두번째 인자에서 default값을 입력할 수 있다. 
    


3. comrfirm //확인함 
  - alert와의 차이점 
      - alert는 확인 버튼만 존재하나 comfirm은 확인과 취소버튼이 있다. 
      - 결과값이 boolean형으로 도출되며 확인은 true, 취소는 false 


--------------------------------------------------------------------------------------------------------------------------------------------------------

[ 형변환 ]

  Q 형변환이 필요한 이유?
    if) 만약 자료형이 다른게 더해지면 어떠한 결과값이 발생할까?
        ex) "문자" + "문자" --> 문자형
            200 + 2000 --> 숫자형
            "문자" + 390  -->  ? 
            --> 에측하지 못한 다른 결과 값이 발생하기 때문 


    ㄱ. 자동형변환 
      "문자형" / 3 --> 결과값 숫자형 
      "문자형" / "문자형" --> 숫자형 
      - 연산/비교 시에 자동형변환이 주로 발생한다. 
      --> 예기치 못한 상황을 발생시키기때문에 명시적으로 형변환을 지켜주어 에러를 방지해야한다. 


    ㄴ. 명시적 형변환  - String(), Number(), Boolean() 

        1. String()
          - 문자형으로 변환 

        2. Number()
          - 숫자형으로 변환 
          - 문자와영어가 섞일경우 ) NaN
          - ture) 1
          - false ) 0 
          * 주의사항 -- 암기필요
            null --> 0
            undefined --> NaN
            0 --> false
            '0' --> ture;
            "" --> false
            ' " -> ture 

        3. Boolean()
          - 불린형으로 변환 
          - 0, "", null, NaN, undefined ) false  
            -> if문 조건문에서 활용되는 Falsy
          - 그외는 모두 ) ture 

--------------------------------------------------------------------------------------------------------------------

[ 연산자 ]

+ , - , * , / , %

- 응용 
- 거듭제곱 :  ** 

  Q) 나머지는 어디에 쓸까?
    - 홀수,짝수, 
    - %5 --> 5보다 작은 수 얻기 

  < 우선 순위 > 
    -  *, / > +,- 


  <연산자 줄여서 쓰기 >
    num += 5 ---> num = num + 5와 같다
      -- 더한뒤 넣어라! 

  < 증가 연산자 / 감소연산자 >(전위 후위)
    - 값을 1만큼 증가 혹은 감소시킨다. 

    - 증가 연산자 ++ 
        - num ++ 
        - ++num 

    - 감소 연산자 -- 
        - num--
        - --num 

    Q) 연산자의 위치에 따른 차이는 ?  
        ex)  let num = 10; 
             let result = num++ // 10 
             let result = ++num // 11 

            num++ 의 경우 그 다음줄 부터 시행된다. 이전값을 담고있다. 
            ++num 의 경우 해당 줄부터 시행된다. 



    < 비교 연산자 >
      > ,  <,  >=, <=, ==, !=
      크다 ,작다, 크거나 같다, 작거나 같다 , 같다 , 같지 않다. 
      -- > 반환 값은 언제나 booleanr값이다. 

      * 특이 사항 
        비교 연산자에는 동등연산자와 일치연산자가 있다.  
        동등연산자 ==,
        일치 연산자  === 

        == 의 경우 타입과 무관하게 값만을 비교하지만 
        ===의 경우 늘어난 =의 숫자처럼 좀더 세부적으로 들어가 값의 타입까지 일치해야 true가 반환된다. 
        --> 따라서 코드를 작성할때는 일치연산자 ===을 쓰는것을 추천한다. 


        < 다양한 비교예시 >
          1. -50,000 ≤ num1 ≤ 50,000 
            a. 먼저 -500000 과 넘을 비교하여 결과값이 ture or false가 된다. 
            b. if true,false는 0 또는 1임이다.
            c. 따라서 0,1 <= 50000을 비교하는게 되어 제대로된 비교가 불가하다. 
            d. -50000 <= num1 && num1 <= 50000 이런식으로 접근하는게 타당하다. 

-----------------------------------------------------------------------------------------------------------------------------------------------------------
[ if 문 ]
- ()조건문의 값이 true면 실행하는 코드  
- 코드가 한줄 뿐이면  {} 를 생략할 수 있다. 

- if문이 판단하는 값은 
  1. boolean의 참/거짓
  2. Truthy(참으로 간주되는 값) / Falsy(거짓으로 간주되는 값) 값
  - 해당값을 조건으로 활용할 수 있습니다. 


  * Falsy의 종류 
    false
    null
    undefined
    0
    NaN
    빈 문자열 ("")

  * Truthy의 종류 
    -  Falsy 값 이외의 모든 값들을 포함
    1. 문자열, (빈 문자열 제외 )
    2. 숫자, (0 제외 )
    3. 객체,
    4.  배열 
    * -1은 true 


    ---> 불리언이 아니더라도 JavaScript는 자동으로 Truthy나 Falsy로 변환하여 조건을 판단합니다. 


    1. if , else , else if 
      - if 는 true일때 실행
      - else는 false일떄 실행 
      - else if 만약 이게 맞다면 
      

    * if문의 조건에 !이들어간다면 false를 true로 바꿔사용하는것이기때문에 false값이 들어와야한다. 


    < treu/false와 비교 연산자가 if문에서 비교된다면?>
      ex)  if(!('age' in mike)<20)
          --> 객체 비교 in의 경우 결과값이 boolean으로 나타난다. 
          -->  ture/false < 20 과 동일한 형태 
          ** 비교연산자는 ture를 1로 판단 
          ** 비교 연산자는 false를 0으로 판단한다. 


    -----------------------------------------------------------------------------------------------------------------------------------------------

    [ 논리 연산자 ]
      1. || (or) : 하나라도 true면 true 
          - or은 첫번째 true를 발견하는 즉시 평가를 멈춘다. 
          < || 의 반환값 ? >
            -->  마지막 true값을 반환한다. 

      2. && (and) : 모든 값이 ture면 ture 
          - 첫번째 false를 발견하는 즉시 평가를 멈춘다. 
      3. not (Not) : ture와 false를 서로 반대값으로 변환 


      논리 연산자 코드 작성의 순서에 관한 tip 
        - 시간을 줄여 성능 최적화를 위한 작성하는 법 
        ex)  운전면허가 있고 시력이 좋은 여군
              - 운전면허 : 80%;
              - 시력이 : 60%;
              - 여군: 8%; 
              -> 여군인데 시력이 좋고 운전면허가 있는 사람 의 순서로 진행되어야함 

      ** 연산자에도 우선순위가 있다. 
        && > ||
        &&가 ||보다 우선 순위가 높다. 
        따라서 && ||를 하나의 조건에 함꼐 사용한다면 숫자 계산 처럼 || 비교 쪽에 ()를 감싸 먼저 할 수 있도록 해준다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------

[ 반복문 ]
- 동일한 작업을 여러번 반복 

1. for 
    for(let i = 0; i < 10; i++){
        // 반복할 코드 
    }
    * 자세히 살펴보기 
      ㄱ. 초기값 :  let i = 0
          - 반복문에 진입할떄 최초 한번만 실행된다. 
      ㄴ. 조건 :  i < 10 ;
          - false가 되면 멈춘다. 
      ㄷ. 반복문 실행후 작업될 영역
        - *후위연산자는 다음줄부터 실행된다는 사실! 
        - 따라서 반복문부터 실행을 마친 후에 실행한다. 


      <코드 진행의 순서 >
      1. 초기값 
      2. 조건문
      3. 실행문
      4. 후위연산자 
      5. 조건문
      6. 실행문
      7. 후위연산자
      8. 조건문 false시 탈출 


2. while 
    let i = 0;
    while(i < 10 ){
      // 반복할 코드 
      i++ (만약 해당 코드가 없다면 i의 값이 증가하지 안아 무한 반복될 수 있다는 점을 유의 )
    }
   
3. do while
    let i = 0; 
    do{
      i++;
    }while(i < 10)
    - while과 차이점 
      while: 주로 선 조건을 체크하고 반복을 시작할 때 사용합니다.
      do-while: 코드 블록을 최소한 한 번 실행하고 나중에 조건을 체크해야 하는 경우에 사용합니다.
      --> 즉, 조건문에 값이 false가 입력되더라도 한번은 코드를 실행합니다. 
      --> ture ,flase 상관없이 무조건 한번 된다고 생각하기 
      --> 주로 사용자에게 최소한번의 입력 기회를 줄때 사용 

< 반복문을 멈추는 방법 >
1. brack : 멈추고 즉시 빠져나옴
2. continue : 멈추고 반복문의 조건문으로 다시 이동 



<주의사항>
while(ture)는 무한반복을 발생합니다. 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ switch문 ]

switch(평가){
  case a :
  // a일떄 코드
  case b : 
  // b일떄 코드 
}
  <주의사항>
    - break를 만나지 않음 해당 케이스부터 브레이크가나올때가 전부 실행하는 특성이 있다. 
    따라서 break를 넣어줘야한다. 

    - case에 없느 경우 처리 ) 
      - default : 를 사용하여 처리한다. 


------------------------------------------------------------------------------------------------------------------------------------------------------------


[ 함수 선언문 ] funtion 
  - 비슷한 동작(기능) 재활용하기 
  - 이름이 있는 함수 선언 
  - 선언부와 호출부가 나눠져있다. 

  ※매개변수 : 함수내에서 전달된 값을 저장하는 임시변수(지역변수라 한다.)
              ** 지역변수는 함수 내부에서만 사용가능해 외부에서 사용이 불가하다. 
              ** 함수외부에서 선언된 변수를 함수 내부에서 사용은 가능하다. 
              ** 단 함수외부에서 선언된 변수를 함수내부에서 사용후 함수 호출부 이후로 해당 변수를 다시 사용하면 함수내부에서 업데이트 된 내용이 저장되어있다. 
  ※인수 : 함수 호출부에서 함수로 전달되는 값 
 
  ※지역변수 
      -- 함수 내부에서만 사용되는 매개변수를 지역변수라 한다. 
  ※전역변수 
      -- 함수 외부에서도 함수 내부에서도 사용가능한 변수를 전역에서 사용가능하다 하여 전역변수라 한다. 



  장점 : 
    1. 코드의 재사용이 효율적이다. 
    2. 유지보수가 간편하다. 

  ex) 대표적인 브라우저 함수 
    - console,alert,comfirm

  
  < 함수 작성법 >
    - 여러가지 작성 법이 있다. 

    1) 함수의 선언 
    funtion 함수명(매개변수){
      // 실행문 
    }
    
    ** 매개변수란 : 
      1. 매개변수는 없을 수도 / 하나일 수도 / 두개일 수도 있다. 


    2) 함수의 호출 
      함수명(); 


    <매개변수가 없는 함수 >
      // 에러를 띄어주는 함수작성 하기 
      funtion showError(){
        alert('에러발생 다시 시도 해주세요 ')
      }
      

    <매개변수가 하나 있는 함수>
      funtion showName(name){
        const msg = `hello ${name}`
        alert(msg)
      }
      Qa) 매개변수가 있으나 매개변수를 전달하지 않을경우 ?
          -- undefined의값이 뜬다. 


    < 인수가 하나도 전달되지 않을 경우 처리해주기  >
       - 함수 호출부에 인수가 전달되지않을경우, 함수내 지역 변수에 undefined값이 할당된다. 
       
       Q) undefined값이 들어 왔을 때 2가지 처리 방법 
          1. || 연산자 사용하기 
          2. default 매개변수 사용하기 

          < || 연산자 사용하기 >
            // 이름을 부르는 기능을 하는 함수 
            // 페이지 전체에 쓰이는 것이 아닌 특정 페이지에서 만 사용되는 기능으로 전역변수 필요없음 
            function sayName(name){
                let msg = name || 'replaceName'; // ||은 마지막 ture를 반환 
                console.log(msg)
            }
            sayName();  //replaceName
            sayName('Mike') // Mike

          
          < default 값 사용하기 >
          function sayName(name = 'defaultName'){
            let msg = `hello ${name}`
            console.log(msg)
          }
          sayName();
          sayName('Mike')


    < 값을 반환하는 함수 >
      -- return 활용하기 
      -- return 우측 값을 반환한다. 
      -- 지역변수 선언 없이 반환되는 값을 전역변수에 담아 활용할 수 있다.  
      -- return이 있으면 즉시 함수가 종료되기 때문에 함수를 종료할려는 목적으로 사용하기도 한다. 
      ※특이사항 
      -- 리턴문이 없는 함수는 항상 undefined를 반환합니다. 
      -- 우측에 반환할 값이 없이 return만 있어도 undefined를 반환합니다. 


      < 함수에서 return을 사용하는 이유 >
        1. 함수외부에서 값을 사용하기 위해서 
          - 콘솔로 할경우 로그에서는 보여지나, 값은 undefine로 활용할 수가겂다. 
        2. 값을 반환후 조기종료가 목표라면
        3. 유지보수, 가독성을 위하여 


      function add(num1,num2){
        return num1 + num2 
      }

      let result = add(1,2);
      console.log(result);


      function showError(){
        alert('이 함수오류가 발생했습니다.)
        return;
        alert('이 부분은 절대 실행되지 않습니다.)
      }

      const result = showError();
      console.log(result)



      <함수 tip >
      1. 한번에 한작업에 집중한다. 
      2. 읽기 쉽고 어떤 동작인지 알 수 있는 네이밍 
-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ 함수 표현식]
  - 이름없는 함수를 생성 후 할당

  let sayHello = function(){
    // 실행코드
  }
  sayHello(); 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

[함수 선언문과 함수 표현신의 차이점]
  - 호출 타이밍이 다르다. 

  함수 선언문 ) 
    - 어디서든 호출 할 수 있다. 
    * 함수 호이스팅이 발생하여 자바스크립트 엔진의 위에서 아래로 코드를 읽는 특성에도 불구하고 호출부가 선언부 보다 위에 있어도 작동한다. 
    
    이유: 자스엔진은 코드 실행전 선언부를 모두 찾아 미리 실행컨텍스트에 선언해두기 때문.. 
    ex) sayHello(); // hello 

        function sayHello(){
        console.log('hello')
        }

  
  함수 표현식 )  
    - 실행되지 않는다. 
    - 표현식의 경우 선언부는 const sayhello임으로 함수선언자체가 위에서 아래로 차례로 읽어가는 런타임 시점에 생성되기 떄문. 
    ex) sayHello();

        const sayHello = function(){
        console.log('hello')
        }

---------------------------------------------------------------------------------------------------------------------------------------------------------


[ 화살표 함수 ]
  - funtion이란 말 없이, 좀더 간략화 된 함수 
  * 리턴문이 한줄이라면 {} 생략가능 
  * 인수가 하나라면 ()로 생략가능 
  
  q)인수가 없는 경우라면 () 생략 가능한가?  No
    - 

 ex)  const sayHello = () => {} 



-------------------------------------------------------------------------------------------------------------------------------------------------------------
[ 지역변수와 전역변수의 차이 ]

  1. 전역변수와 지역변수의 명은 동일할 수 있다.
  2. 둘의 값은 서로 영향을 받지 않고 독립적인 값을 유지한다. 
  3. 만약 지역변수가 없다면 동일한이름을 가진 전역변수의 값을 사용한다.
  4. 전역변수 보다는 지역변수를 활용하는 습관을 가지자 
      ㄴ 전역변수가 많이지면 관리가 힘들어진다. 

Q) 전역변수와 함수 내부의 지역변수명이 동일 할 수 있을까 ? --> 가능하다 
  1.  함수와 내부에서 동일한 명의 변수를 선언할 수 있다. 
  2.  변수 내부의 값은 서로 영향을 받지 않는다. 

  ex) let msg = '전역변수'
      
      console.log(msg) // 전역변수 

      funtion sayMsg(name){
        let msg = '지역변수'
        console.log(msg + '' + name) // 지역변수 입니다. 
        console.log( + name) 
      }

      sayMsg('입니다.')
      sayMsg(); //undefined
      console.log(msg) // 전역변수 


  ex) let msg = '전역변수'
      
      console.log(msg) 

      function sayMsg(name){
        // let msg = '지역변수'
        console.log(msg + '' + name)
        console.log(name)  
      }

      sayMsg('입니다.')
      console.log(msg)
      --> 지역변수가 없다면 동일한 이름의 전역변수를 사용한다. 


  ------------------------------------------------------------------------------------------------------------------------------------------------------

  [ 객체 object]
    - 프로포티들로 구성되어있다. 
    - 접근, 추가, 수정, 삭제 등이 가능하다. 

    <프로포티의 구성>
    1. 키(key) :  문자열 || 심볼 
    2. 값(value) : 모든 데이터 타입 가능 

    <객체의 형태>
    const Character = {
      name: 'mike', // 속성, 문자
      age : 48, // 속성, 숫자 
      friend ; ['1','2','3'], // 속성, 배열,
      sayHello : function(){ // 메소드, 함수 
        console.log('hello')
      }
    }
      --> 위에서 볼 수 있듯이 객체는 다음과 같은 타입을 모두 담을 수 있다. 
      < 프로퍼티로 가능한 타입>
      1. 숫자,
      2. 문자열,
      3. boolean,
      4. 객체,
      5. 배열,
      6. 함수,
      7. null/undefined
    
    속성 호출 :  객체.속성명 , 객체['속성명']
    메소드 호출 : 객체,속성명() 

    <주의사항>
    1. 프로포티의 키와 값이 동일할 경우 하나로 줄여쓰느 단축 프로퍼티가 가능하다. 
    ex) const Character = {
        name,
        age,
    }

    2. 프로퍼티의 키는 문자열로 반환된다. 
       Object.Key(객체명) // ['age', 'name']
       --> 따라서 접근할떄 [''] 따음표를 사용해야한다.   


    < 객체의 접근 >
    Character.name
    Character[age]

      1. 프로포티의 존재유무 확인 
          if) 접근하는 프로퍼티가 없는 프로퍼티라면 undefined를 반환한다.   
          --> undefined는 조건문에서 false이다.        
          -----------------------------------------------------------
          in 사용법 
            console.log('프로퍼티 키' in 객체명 )
            -->  존재한다면 true , 존재하지 않는다면 false가 나온다. 

      2. 프로포티 순회하기 
          - for in 접근 방법 
          for(x in mike){console.log(mike[x])} // mike['프로퍼티1'], mike['프로퍼티2'] 
          -- x에는 mike의 프로퍼티가 존재한다. 
          --> for in을 사용하여 모든 객체를 순회할 수 있다. 

    < 객체의 추가 >
    Character.name = '';
    Character[] = ''; ※주의사항 :  [ ' '] 접근할려는 프로퍼티를 문자열로 감싸줘야한다. 


    < 객체의 삭제 >
    delete Character.name

---------------------------------------------
 
  [ 계산된 프로퍼티 ]
  - 객체 프로퍼티 키가 []로 감싸진 경우, 계산된 프로퍼티라 부른다. 
  - 변수의 값을 프로퍼티의 키로 활용하여 키를 동적으로 결정할 수 있다. 

  let fulut = prompt('가방안 물건을 입력해주세요')
  let bag = {
    [fulut] = 5; 
  }
  만약 애플을 입력했다면?
  console.log(bag.apple) // 5

  -----------------------------------------------------------------------------------------------------------------------------------------------------------

  [ 메소드 ] method
    - 함수로 이뤄진 객체의 프로퍼티를 메소드라 하며, 객체의 동작을 나타낸다. 
    - 객체에 선언된 함수임으로 호이스팅과 무관하다. 

    ex) const superman(){
      name: 'july',
      age: 30,
      fly: function(){
        console.log('날아갑니다') // 메소드 
      }
      walk(){
        console.log('걸어갑니다.') // 단축구문 
      }
    }

    
    ---------------------------------------------------------------------------------------------------------------------------------------------------------

  [ 객체의 메소드 ]

  1. Object.assign()
  2. Object.Keys()
  3. Object.values()
  4. Object.entries()
  5. Object.fromEnties() 


    1. Object.assign()
      - 객체 복사하는 메소드 
      const NewUser = Object.assign({}, 원본객체명 )
      const NewUser = Object.assign({ name: 'mike'}, 원본객체명 )
      const NewUser = Object.assign(객체명,객체명, 객체명 )
      - 반환값은 언제나 하나의 객체, 
      - 동일한 프로퍼티는 덮어씌어진다. 

      Q) 객체복사 이해하기 
        ex) const user = {
          name: 'hoby'
        }
        const cloneUser = user;
        - 새로운 변수에 객체를 할당할 경우 복사되는것이 아닌 user라는 식별자가 가지고 있는 참조 주소가 할당되게 된다. 
        - 따라서 복사되는것이 하닌 하나의 주소를 두개의 변수가 동시에 같이 사용함게 됨으로서  cloneUser의 name을 변경하게 되면, 원본객체 user의 이름도 함께 변경된다.
        - 이는 올바른 복사 방법이 아니기 때문에 Object.assign을 통해 객체의 복사가 가능하다. 


      2. Object.Keys()
        - 객체 프로퍼티의 키를 배열로 반환한다. 
        - Object.Keys(객체명) 

      3. Object.value()
        - 객체 프로퍼티의 값을 배열로 반환한다.  
      
      4. Object.entries()
        - 객체 프로퍼티를 배열로 반환한다. 
        [
          [키,값]
          [키,값]
        ]

      5. Object.fromEnties()
        - 키값 배열을 객체로 반환한다. 

      6. 


    ----------------------------------------------------------------------------------------------------------------------------------------------------------
    [ this ]  * 어려운 구간 
    - 사용되는 위치에 따라 this가 가르키는 대상이 달라지는 특별한 코드 

     1. this는 실행하는 시점, 런타임 시점에 결정된다. 

    0) 일반함수로 호출로 this가 사용된 경우 
      ex)  function foo(){ console.log(this)} 
           foo();
           --> this는 전역객체를 가리킨다. 

    1) 화살표 함수 내부에서 this가 사용된경우 
       - 화살표 함수는 자신만의 this를 가지지 않는다. 따라서 this의 해당하는 값을 외부을 가져온다. 
       -  상위 스코프의 메소드를 따르며
       - 최상단의 스코프 단위에사용된 화살표 함수라면 화살표함수는 전역객체를 가르킨다. 

       ※전역객체
         - 브라우저 : window()
         - node 환경 : global


     2 ) 일반함수의 메소드로 this가 사용된 경우 
        - const obj = {foo}
          obj.foo()
        - obj 객체안에 this가 있다면 this는 해당 객체를 가리킨다. 

     3) 생성자 함수에 this 
        - function Item(title,name){
          this.title =title
          this.name = name 
        }
        const item1 = new Item();
        --> 미래해 생성된 인스턴스(객체)를 가리킨다. 




-------------------------------------------------------------------------------------------------------------------------------------------------------------

[ 배열 ] array 
- 순서가 있는 리스트 

let student = []


< 배열의 특징 >
1. 자바스크립트는 배열도 원래 객체이다. 하지만 둘을 그분 짓는 배열의 특징이 존재한다. 
?) 배열 과 객체의 차이점은 ? 
   1. 고유번호 index의 유무
   2. 순서의 중요도 
   3. 배열의 길이 length의 보유 



< 배열의 접근 >
- student[고유번호(index)]


2. 배열에는 문자, 숫자, 객체, 함수를 포함할 수 있다. 
3. 배열은 메소드를 가지고 있다. 
   - push() 배열끝에 요소 추가 / 원본유지여부 : 
   - pop() 배열끝에 요소 제거 / 원본유지여부 : 
   - unshift() 배열 앞에 요소 추가 / 원본유지여부 : 
   - shift() 배열앞에 요소 제거 / 원본 유지 여부 : 


< 배열의 순회 >
1. for 문 사용 
   for(let index = 0; index < day.length; index++){
    console.log(days[index])
   }
2. for of 사용 
   for(day of days){
    console.log(day)
   }


------------------------------------------------------------------------------------------------------------------------------------------------



 [ 생성자 함수 constructor function ] 

 - 진 객체를 생성하는 특별한 함수를 의미한다. 
 - 함수명은 반드시 대문자여야한다.
 - new 키워드를 사용해야한다.  
 - return문 없이 객체를 반환한다. 
 - 생성자 함수를 통해 반환되는 객체는 빈 객체이며 인스턴스( instance )라 부른다. 
 - this를 사용하여 반환되는 객체의 초기상태와 행위를 정의한다. 

 <기본구조 >
  function Item(title,price){ 
    // this = {} ;  // 암묵적으로 빈객체가 생성되고 this 바인딩되며, 런타임이전에 처리된다. 
    this.title = title;  // 런타임시점에 한줄한줄 초기화 된다. 
    this.price = price;
    this.sayItem = function(){
      console.log(`이 제품은 ${this.title}이며, 가격은 ${this.price}입니다.`)
    }
    // return this  // 암묵적으로 this를 반환한다. 
  }
  const itme1 =  new Item('사과', 3000)

---------------------------------
  <생성자 함수와 일반함수의 차이점 >
  1. 일반적인 함수로 객체를 반환하는 함수는 return문을 사용하여 객체를 반환해야하지만
   생성자 함수를 사용할경우 return문 없이 객체생성이 가능하다.
----------------------------------


 < new키워드를 사용하지 않는다면 일반함수와 동일하게 동작한다. > 

    function Item(title,price){
    // new를 사용하지 않으면 this = {} , return this가 생략되어 반환 값이 없어 undefined가 암묵적으로 반환됩니다. 
    // this는 전역객체 whindw를 가리킨다. 
    // this = {} ; 
    this.title = title;
    this.price = price;
    this.sayItem = function(){
      console.log(`이 제품은 ${this.title}이며, 가격은 ${this.price}입니다.`)
    }
    // return this 
  }

    !) 단, 기본적으로 내장되 객체 생성자 함수는 new 키워드 없이도 빈 인스턴스를 생성한다. 
        -- > Object / Array / function / String / Number / Boolean / Date / RegExp 
 
------------------------------------ 
 <함수간의 비교>
 1. 함수 선언문과 함수 표현식은 this 처리가 적절하게 이루어져 생성자 함수로 사용이 가능하다. 
 2. 화살표 함수는 자신만의 this를 생성하지 않기 때문에 this처리가 이뤄지지 않아 생성자 함수로 사용이 불가하다. 

-------------------------------------
< 생성자 함수를 사용해야하는 이유??  >
 - 생성자 함수를 사용해 수십개의 동일한 프로퍼티 구조를 가진 객체 여러개를 간편하게 생성할 수 있기 때문
 - 객체 리터럴의 경우 직관적이지만, 동일한 프로퍼티의 구조를 가진 객체여러개를 생성할 때 수십개면 수십개를 생성해야하기 때문에 불편하다. 



